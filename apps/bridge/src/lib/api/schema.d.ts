/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
	'/v1/capabilities': {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/**
		 * Get current capabilities graph
		 * @description Returns the live "graph" of what is possible right now (chains, assets, and routes).
		 *     This endpoint is descriptive only and does not create commitments.
		 */
		get: operations['getCapabilities'];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	'/v1/orders': {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Create an order (idempotent)
		 * @description Creates an order from a quote.
		 *
		 *     Idempotency:
		 *     - Requires `Idempotency-Key` header.
		 *     - Repeating the same request with the same key should return the same order.
		 */
		post: operations['createOrder'];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	'/v1/orders/{orderId}': {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		/** Get an order (single source of truth) */
		get: operations['getOrder'];
		put?: never;
		post?: never;
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
	'/v1/quotes': {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		get?: never;
		put?: never;
		/**
		 * Create a quote
		 * @description Creates an ephemeral quote ("offer") which:
		 *     - selects the best route right now
		 *     - has an expiry
		 *     - fully defines expected fees and deposit expectations
		 */
		post: operations['createQuote'];
		delete?: never;
		options?: never;
		head?: never;
		patch?: never;
		trace?: never;
	};
}
export type webhooks = Record<string, never>;
export interface components {
	schemas: {
		/**
		 * @description CAIP-10 account identifier (e.g. "eip155:1:0xabc...").
		 * @example eip155:42161:0xRecipientAddress
		 */
		AccountId: string;
		/**
		 * @description Base-unit integer amount encoded as a string (no decimals).
		 * @example 0
		 * @example 1000000
		 */
		Amount: string;
		AssetFamily: {
			/**
			 * @description Stable, human-meaningful identifier (e.g. "usdc").
			 * @example usdc
			 */
			assetFamilyId: string;
			/**
			 * @description Denomination currency (e.g. "USD").
			 * @example USD
			 */
			currency: string;
			/** @example circle */
			issuer: string;
			/** @example USD Coin */
			name: string;
			representations: components['schemas']['Representation'][];
			/** @example USDC */
			symbol: string;
		};
		/**
		 * @description CAIP-19 asset identifier (e.g. "eip155:1/erc20:0xa0b8...").
		 * @example eip155:1/erc20:0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48
		 */
		AssetId: string;
		Capabilities: {
			assetFamilies: components['schemas']['AssetFamily'][];
			/**
			 * Format: date-time
			 * @description Monotonic capabilities version timestamp.
			 */
			capabilitiesVersion: string;
			/** @description Refund policy modes supported by the service (informational). */
			refundPolicyModes?: components['schemas']['RefundPolicyMode'][];
			routes: components['schemas']['Route'][];
		};
		/**
		 * @description CAIP-2 chain identifier (e.g. "eip155:1").
		 * @example eip155:1
		 * @example tron:0x2b6653dc
		 */
		ChainId: string;
		CreateOrderRequest: {
			/** @example qt_01J... */
			quoteId: string;
			recipient: components['schemas']['AccountId'];
			refund?: components['schemas']['OrderRefundRequest'];
		};
		DepositAcceptance: {
			/**
			 * @description Overpay policy. Known values: "refund_excess", "cap", "accept".
			 * @example refund_excess
			 */
			overpay: string;
			/**
			 * @description Underpay policy. Known values: "await_remainder", "partial_fill", "reject".
			 * @example await_remainder
			 */
			underpay: string;
		};
		DepositDefaults: {
			maxAcceptedAmount: components['schemas']['Amount'];
			minAcceptedAmount: components['schemas']['Amount'];
			/**
			 * @description Overpay behavior. Known values: "refund_excess", "cap", "accept".
			 * @example refund_excess
			 */
			overpayBehavior: string;
			/**
			 * @description Underpay behavior. Known values: "await_remainder", "partial_fill", "reject".
			 * @example await_remainder
			 */
			underpayBehavior: string;
		};
		DepositFill: {
			minFillAmount?: components['schemas']['Amount'];
			/**
			 * @description Fill mode (e.g. "proportional").
			 * @example proportional
			 */
			mode?: string;
			partialFillSupported: boolean;
		} & unknown;
		DepositRequirement: {
			acceptance: components['schemas']['DepositAcceptance'];
			/** @description Deposit address on the source chain. */
			address: string;
			assetId: components['schemas']['AssetId'];
			expectedAmount: components['schemas']['Amount'];
			/** Format: date-time */
			expiresAt: string;
			fill: components['schemas']['DepositFill'];
			maxAcceptedAmount: components['schemas']['Amount'];
			/** @description Optional memo/tag for chains that require it. */
			memo?: string | null;
			minAcceptedAmount: components['schemas']['Amount'];
		};
		FamilySelector: {
			/** @description Asset family id (e.g. "usdc"). */
			assetFamilyId: string;
			chainId: components['schemas']['ChainId'];
		};
		FeeComponent: components['schemas']['PpmFee'] | components['schemas']['FlatFee'];
		FeePreview: {
			effectiveInputAmount: components['schemas']['Amount'];
			feeTotal: components['schemas']['Amount'];
		};
		FlatFee: {
			amount: components['schemas']['Amount'];
			/**
			 * @description Fee base (e.g. "perOrder").
			 * @example perOrder
			 */
			appliesTo: string;
			assetId: components['schemas']['AssetId'];
			/**
			 * @description Proration policy (e.g. "first_fill").
			 * @example first_fill
			 */
			proration: string;
			/**
			 * @description discriminator enum property added by openapi-typescript
			 * @enum {string}
			 */
			type: 'FlatFee';
		};
		NextAction: {
			message?: string;
			/**
			 * @description Next action type (e.g. "send_more").
			 * @example send_more
			 */
			type: string;
		};
		Order: {
			amounts: components['schemas']['OrderAmounts'];
			/** Format: date-time */
			createdAt: string;
			depositRequirement?: components['schemas']['DepositRequirement'];
			fees: components['schemas']['FeeComponent'][];
			nextAction?: components['schemas']['NextAction'];
			/** @example ord_01J... */
			orderId: string;
			/**
			 * Format: int32
			 * @description Recommended polling interval hint.
			 */
			pollAfterSeconds?: number;
			quote?: components['schemas']['OrderQuoteSummary'];
			recipient: components['schemas']['AccountId'];
			refund?: components['schemas']['OrderRefund'];
			refundPolicy: components['schemas']['RefundPolicy'];
			resolution?: components['schemas']['Resolution'];
			/**
			 * @description Order status.
			 *     Known values: "requires_funding", "funding_incomplete", "funding_detected", "executing",
			 *     "settling", "completed", "action_required", "failed", "expired", "canceled".
			 * @example requires_funding
			 */
			status: string;
			/**
			 * @description More specific status indicator (e.g. "manual_refund_required").
			 * @example manual_refund_required
			 */
			substatus?: string;
		};
		OrderAmounts: {
			acceptedAmount: components['schemas']['Amount'];
			estimatedToAmount?: components['schemas']['Amount'];
			excessAmount: components['schemas']['Amount'];
			feePreview: components['schemas']['FeePreview'];
			receivedAmount: components['schemas']['Amount'];
			remainingAmount: components['schemas']['Amount'];
		};
		OrderQuoteSummary: {
			/** Format: date-time */
			expiresAt: string;
			/** @example qt_01J... */
			quoteId: string;
		};
		OrderRefund: {
			destination?: components['schemas']['RefundAssetDestination'];
			excessAmount: components['schemas']['Amount'];
			/**
			 * @description Refund status (e.g. "pending", "completed", "failed").
			 * @example pending
			 */
			status: string;
		};
		OrderRefundRequest: {
			to?: components['schemas']['AccountId'];
		};
		PpmFee: {
			/**
			 * @description Fee base (e.g. "acceptedAmount").
			 * @example acceptedAmount
			 */
			appliesTo: string;
			/**
			 * @description What asset the fee is charged in (e.g. "fromAsset").
			 * @example fromAsset
			 */
			chargedIn: string;
			/**
			 * Format: int32
			 * @description Proportional fee in parts-per-million.
			 */
			ppm: number;
			/**
			 * @description Proration policy (e.g. "proportional").
			 * @example proportional
			 */
			proration: string;
			/**
			 * @description discriminator enum property added by openapi-typescript
			 * @enum {string}
			 */
			type: 'PpmFee';
		};
		/**
		 * @description RFC 7807 Problem Details (application/problem+json).
		 *     Additional fields (e.g. errorCode, allowedRefundChainIds) may be provided.
		 */
		Problem: {
			/** @description A human-readable explanation specific to this occurrence. */
			detail?: string;
			/** @description Service-specific stable error code. */
			errorCode?: string;
			/**
			 * Format: uri
			 * @description A URI reference that identifies the specific occurrence of the problem.
			 */
			instance?: string;
			/**
			 * Format: int32
			 * @description The HTTP status code.
			 */
			status: number;
			/** @description A short, human-readable summary of the problem. */
			title: string;
			/**
			 * Format: uri
			 * @description A URI reference that identifies the problem type.
			 */
			type: string;
		};
		Quote: {
			depositDefaults: components['schemas']['DepositDefaults'];
			estimatedToAmount: components['schemas']['Amount'];
			/** Format: date-time */
			expiresAt: string;
			fees: components['schemas']['FeeComponent'][];
			fromAmount: components['schemas']['Amount'];
			fromAssetId: components['schemas']['AssetId'];
			/** @example qt_01J... */
			quoteId: string;
			refundPolicyPreview: components['schemas']['RefundPolicyPreview'];
			route: components['schemas']['RoutePlan'];
			toAssetId: components['schemas']['AssetId'];
		};
		/**
		 * @description Quote request.
		 *
		 *     Canonical form uses CAIP-19 asset ids.
		 *     Optional "family sugar" form uses (chainId, assetFamilyId) pairs.
		 */
		QuoteRequest:
			| components['schemas']['QuoteRequestCanonical']
			| components['schemas']['QuoteRequestFamily'];
		QuoteRequestCanonical: {
			fromAmount: components['schemas']['Amount'];
			fromAssetId: components['schemas']['AssetId'];
			recipient: components['schemas']['AccountId'];
			refundTo?: components['schemas']['AccountId'];
			/**
			 * Format: int32
			 * @description Maximum acceptable slippage in basis points.
			 */
			slippageBps?: number;
			toAssetId: components['schemas']['AssetId'];
		};
		QuoteRequestFamily: {
			from: components['schemas']['FamilySelector'];
			fromAmount: components['schemas']['Amount'];
			recipient: components['schemas']['AccountId'];
			refundTo?: components['schemas']['AccountId'];
			/** Format: int32 */
			slippageBps?: number;
			to: components['schemas']['FamilySelector'];
		};
		RefundAssetDestination: {
			assetId: components['schemas']['AssetId'];
			chainId: components['schemas']['ChainId'];
		};
		RefundFees: {
			estimatedMaxFee?: components['schemas']['Amount'];
			/** @description Whether the refund path may incur a bridge fee. */
			mayIncurBridgeFee?: boolean;
			/**
			 * @description Who pays refund-related fees. Known values: "user", "service".
			 * @example user
			 */
			payer?: string;
			/**
			 * @description Refund fee handling. Known values: "deduct_from_refund".
			 * @example deduct_from_refund
			 */
			policy?: string;
		};
		RefundPolicy: {
			defaultDestination?: components['schemas']['RefundAssetDestination'];
			mode: components['schemas']['RefundPolicyMode'];
			refundFees?: components['schemas']['RefundFees'];
			requiresRefundAddress?: boolean;
			supportedRefundDestinations: components['schemas']['RefundAssetDestination'][];
		};
		/**
		 * @description Refund policy mode.
		 *     Known values: "automatic", "automatic_if_supported", "manual_required", "not_supported".
		 * @example automatic
		 */
		RefundPolicyMode: string;
		RefundPolicyPreview: {
			defaultDestination?: components['schemas']['RefundAssetDestination'];
			mode: components['schemas']['RefundPolicyMode'];
			refundFees?: components['schemas']['RefundFees'];
			supportedRefundDestinations: components['schemas']['RefundAssetDestination'][];
		};
		Representation: {
			assetId: components['schemas']['AssetId'];
			chainId: components['schemas']['ChainId'];
			/** Format: int32 */
			decimals: number;
		};
		Resolution: {
			message?: string;
			/** @description Reference code for support workflows. */
			supportReference?: string;
			/**
			 * @description Resolution type (e.g. "contact_support").
			 * @example contact_support
			 */
			type: string;
		};
		Route: {
			features: components['schemas']['RouteFeatures'];
			fromChainId: components['schemas']['ChainId'];
			pairs: components['schemas']['RoutePair'][];
			toChainId: components['schemas']['ChainId'];
		};
		RouteFeatures: {
			overpayRefund: boolean;
			partialFill: boolean;
			refundDestinations: boolean;
		};
		RoutePair: {
			/** @description Asset family id (e.g. "usdt"). */
			fromFamily: string;
			/** @description Asset family id (e.g. "usdc"). */
			toFamily: string;
		};
		RoutePlan: {
			/**
			 * @description Route type identifier (e.g. "bridge_then_swap").
			 * @example bridge_then_swap
			 */
			kind: string;
			/**
			 * @description Opaque route data for server use (e.g. base64).
			 * @example base64/or/whatever
			 */
			opaque: string;
		};
	};
	responses: {
		/** @description Error response (RFC 7807 Problem Details) */
		Problem: {
			headers: {
				[name: string]: unknown;
			};
			content: {
				'application/problem+json': components['schemas']['Problem'];
			};
		};
	};
	parameters: {
		/** @description Required idempotency key for order creation. Replays with the same key should not create duplicates. */
		IdempotencyKey: string;
		/** @description Optional ETag value from a prior capabilities response. */
		IfNoneMatch: string;
		/** @description Server-generated order identifier. */
		OrderId: string;
		/** @description Optional client-provided order identifier (for UX/debugging). */
		XClientOrderId: string;
	};
	requestBodies: never;
	headers: never;
	pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
	getCapabilities: {
		parameters: {
			query?: never;
			header?: {
				/** @description Optional ETag value from a prior capabilities response. */
				'If-None-Match'?: components['parameters']['IfNoneMatch'];
			};
			path?: never;
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Current capabilities */
			200: {
				headers: {
					/** @description Caching policy (recommendation: max-age=60) */
					'Cache-Control'?: string;
					/** @description Entity tag for caching */
					ETag?: string;
					[name: string]: unknown;
				};
				content: {
					'application/json': components['schemas']['Capabilities'];
				};
			};
			/** @description Not Modified */
			304: {
				headers: {
					[name: string]: unknown;
				};
				content?: never;
			};
			default: components['responses']['Problem'];
		};
	};
	createOrder: {
		parameters: {
			query?: never;
			header: {
				/** @description Required idempotency key for order creation. Replays with the same key should not create duplicates. */
				'Idempotency-Key': components['parameters']['IdempotencyKey'];
				/** @description Optional client-provided order identifier (for UX/debugging). */
				'X-Client-Order-Id'?: components['parameters']['XClientOrderId'];
			};
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				'application/json': components['schemas']['CreateOrderRequest'];
			};
		};
		responses: {
			/** @description Order (idempotent replay) */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					'application/json': components['schemas']['Order'];
				};
			};
			/** @description Order created */
			201: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					'application/json': components['schemas']['Order'];
				};
			};
			default: components['responses']['Problem'];
		};
	};
	getOrder: {
		parameters: {
			query?: never;
			header?: never;
			path: {
				/** @description Server-generated order identifier. */
				orderId: components['parameters']['OrderId'];
			};
			cookie?: never;
		};
		requestBody?: never;
		responses: {
			/** @description Order */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					'application/json': components['schemas']['Order'];
				};
			};
			default: components['responses']['Problem'];
		};
	};
	createQuote: {
		parameters: {
			query?: never;
			header?: never;
			path?: never;
			cookie?: never;
		};
		requestBody: {
			content: {
				'application/json': components['schemas']['QuoteRequest'];
			};
		};
		responses: {
			/** @description Quote */
			200: {
				headers: {
					[name: string]: unknown;
				};
				content: {
					'application/json': components['schemas']['Quote'];
				};
			};
			default: components['responses']['Problem'];
		};
	};
}
